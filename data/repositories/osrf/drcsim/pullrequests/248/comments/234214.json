{"links": {"self": {"href": "data/repositories/osrf/drcsim/pullrequests/248/comments/234214.json"}, "html": {"href": "#!/osrf/drcsim/pull-requests/248/_/diff#comment-234214"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 248, "links": {"self": {"href": "data/repositories/osrf/drcsim/pullrequests/248.json"}, "html": {"href": "#!/osrf/drcsim/pull-requests/248"}}, "title": "per issue #194, alternative solution, add ROS service, allowing user to change joint damping with hard coded per joint bounds"}, "content": {"raw": "Let me first respond to Steven Peters comment. LQR design is a good way to spread gains across joints. For us, it sets the ankle joint\ndamping to about 100, and damping elsewhere to be less. So yes, you can spread the gains. Reasonable design techniques set the ankle damping to be about 100. Stabilization is not the same thing as eliminating sway. Very low ankle damping gains can stabilize the robot. But sway puts the COM close to the edges of the support polygon, increasing the risk of falling over with disturbances.\n\nTo Twan Koolen: CFM Damping is just another way to implement damping, which seems to be better than the current way.\n\nThe real problem we are trying to solve is that the velocity is very noisy, and our ability to do stuff from ROS is severly limited by the delay and dropouts (which worst case reduce our controller bandwidth compared to a Gazebo plugin by about a factor of 5, even with the SYNC mechanism, since we have to handle the worst case drop out).\n\nHow do we make the PD control on the simulator useful, given the large velocity noise?\n\nMethod 1: Implement the D gain as CFM damping, controllable on each tick. I really like this solution. People who want low damping\ncan have it. People who want high damping can have it. CFM damping seems to be a much better implementation of damping that\nusing SetForce(), in terms of actually being an energy sink.\n\nMethod 2: Implement user settable filterering (a crude form of state estimation) as part of the local PD control.\n\nBy the way, with joint torque control on our hydraulic humanoid robot we can make the damping very small, or even negative, as well as making it quite large. So arguments that CFM damping values have something to do with how the robot actually works are a little suspect, or the robot has crappy joint torque control (which I doubt).\n", "markup": "markdown", "html": "<p>Let me first respond to Steven Peters comment. LQR design is a good way to spread gains across joints. For us, it sets the ankle joint\ndamping to about 100, and damping elsewhere to be less. So yes, you can spread the gains. Reasonable design techniques set the ankle damping to be about 100. Stabilization is not the same thing as eliminating sway. Very low ankle damping gains can stabilize the robot. But sway puts the COM close to the edges of the support polygon, increasing the risk of falling over with disturbances.</p>\n<p>To Twan Koolen: CFM Damping is just another way to implement damping, which seems to be better than the current way.</p>\n<p>The real problem we are trying to solve is that the velocity is very noisy, and our ability to do stuff from ROS is severly limited by the delay and dropouts (which worst case reduce our controller bandwidth compared to a Gazebo plugin by about a factor of 5, even with the SYNC mechanism, since we have to handle the worst case drop out).</p>\n<p>How do we make the PD control on the simulator useful, given the large velocity noise?</p>\n<p>Method 1: Implement the D gain as CFM damping, controllable on each tick. I really like this solution. People who want low damping\ncan have it. People who want high damping can have it. CFM damping seems to be a much better implementation of damping that\nusing SetForce(), in terms of actually being an energy sink.</p>\n<p>Method 2: Implement user settable filterering (a crude form of state estimation) as part of the local PD control.</p>\n<p>By the way, with joint torque control on our hydraulic humanoid robot we can make the damping very small, or even negative, as well as making it quite large. So arguments that CFM damping values have something to do with how the robot actually works are a little suspect, or the robot has crappy joint torque control (which I doubt).</p>", "type": "rendered"}, "created_on": "2013-05-03T22:33:19.997352+00:00", "user": {"display_name": "Chris Atkeson", "uuid": "{3bdaa162-b747-4fa9-9d6e-a2d5c92933c6}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3bdaa162-b747-4fa9-9d6e-a2d5c92933c6%7D"}, "html": {"href": "https://bitbucket.org/%7B3bdaa162-b747-4fa9-9d6e-a2d5c92933c6%7D/"}, "avatar": {"href": "https://bitbucket.org/account/catkeson/avatar/"}}, "nickname": "catkeson", "type": "user", "account_id": null}, "updated_on": "2013-05-03T22:38:56.190817+00:00", "type": "pullrequest_comment", "id": 234214}