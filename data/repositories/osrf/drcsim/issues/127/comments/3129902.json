{"links": {"self": {"href": "data/repositories/osrf/drcsim/issues/127/comments/3129902.json"}, "html": {"href": "#!/osrf/drcsim/issues/127#comment-3129902"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/drcsim/issues/127.json"}}, "type": "issue", "id": 127, "repository": {"links": {"self": {"href": "data/repositories/osrf/drcsim.json"}, "html": {"href": "#!/osrf/drcsim"}, "avatar": {"href": "data/bytebucket.org/ravatar/{247b5408-ae91-4e3c-b2f9-a21994658d11}ts=c_plus_plus"}}, "type": "repository", "name": "drcsim", "full_name": "osrf/drcsim", "uuid": "{247b5408-ae91-4e3c-b2f9-a21994658d11}"}, "title": "Bad joint_states when in Nominal mode"}, "content": {"raw": "Thanks for opening this Thomas.  Between the DRC forums, Gazebo Answers, and this, it's hard to keep track of all the places I should be looking for answers to problems.\n\nI think I figured out the root cause of this.  It looks like the neck (at least -- that's what I've been using to easily find and reproduce errors) requires a constant Force of around 1.1 to remain \"stable\" in Nominal mode.  So when Atlas becomes unpinned, it starts with the neck at 0 and the setpoint at 0.  Because this results in no force, the neck quickly starts moving negatively (weird since I would think the head would be front heavy) until it stablizes around -0.05 radian with a constant force around 1.1 trying to push it back to 0.\n\nIf then, one sends a joint_command to the neck to go to -0.05 (let's say we are running a continuous controller that tries to keep the neck still), then the position error immediately goes to 0 from 0.05, the derivative goes really largely low, which causes the head to move even further into negative territory.  Where again, it settles with a force around 1.1-1.2 which another -0.05 offset (head now at -.1 with set point at -0.05).  \n\nIn theory, this steady-state offset can be overcome by the integral controller.  However, having to tune the full PID in Nominal mode is nearly impossible, as the robot falls anytime a bad paramter is given.  If we do have to tune all PID parameters because of steady state offset, then at least the \"pinned mode\" have similar steady state offset issues so that we can tune controllers that way.\n\nAdditionally, because of this difference in Nominal versus pinned offset, then there is always a \"catchup\" period once the robot unpins where the users' controllers have to integrate error over time in order to push the joints back to the original 0 set points.\n\nTomorrow I will investigate to see if joints other than neck have noticable differences between pinned and nominal/unpinned joint states.", "markup": "markdown", "html": "<p>Thanks for opening this Thomas.  Between the DRC forums, Gazebo Answers, and this, it's hard to keep track of all the places I should be looking for answers to problems.</p>\n<p>I think I figured out the root cause of this.  It looks like the neck (at least -- that's what I've been using to easily find and reproduce errors) requires a constant Force of around 1.1 to remain \"stable\" in Nominal mode.  So when Atlas becomes unpinned, it starts with the neck at 0 and the setpoint at 0.  Because this results in no force, the neck quickly starts moving negatively (weird since I would think the head would be front heavy) until it stablizes around -0.05 radian with a constant force around 1.1 trying to push it back to 0.</p>\n<p>If then, one sends a joint_command to the neck to go to -0.05 (let's say we are running a continuous controller that tries to keep the neck still), then the position error immediately goes to 0 from 0.05, the derivative goes really largely low, which causes the head to move even further into negative territory.  Where again, it settles with a force around 1.1-1.2 which another -0.05 offset (head now at -.1 with set point at -0.05).  </p>\n<p>In theory, this steady-state offset can be overcome by the integral controller.  However, having to tune the full PID in Nominal mode is nearly impossible, as the robot falls anytime a bad paramter is given.  If we do have to tune all PID parameters because of steady state offset, then at least the \"pinned mode\" have similar steady state offset issues so that we can tune controllers that way.</p>\n<p>Additionally, because of this difference in Nominal versus pinned offset, then there is always a \"catchup\" period once the robot unpins where the users' controllers have to integrate error over time in order to push the joints back to the original 0 set points.</p>\n<p>Tomorrow I will investigate to see if joints other than neck have noticable differences between pinned and nominal/unpinned joint states.</p>", "type": "rendered"}, "created_on": "2013-02-13T23:47:03.914509+00:00", "user": {"display_name": "Patrick Beeson", "uuid": "{d33f061a-d3c9-4b15-96cc-d08b463d97c6}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bd33f061a-d3c9-4b15-96cc-d08b463d97c6%7D"}, "html": {"href": "https://bitbucket.org/%7Bd33f061a-d3c9-4b15-96cc-d08b463d97c6%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/initials/PB-0.png"}}, "nickname": "Patrick Beeson", "type": "user", "account_id": "557058:eff3a3b0-e19b-43e6-b0a0-22d6a8721c3b"}, "updated_on": "2013-02-14T01:59:24.386672+00:00", "type": "issue_comment", "id": 3129902}