{"links": {"self": {"href": "data/repositories/osrf/drcsim/issues/101/comments/3608339.json"}, "html": {"href": "#!/osrf/drcsim/issues/101#comment-3608339"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/drcsim/issues/101.json"}}, "type": "issue", "id": 101, "repository": {"links": {"self": {"href": "data/repositories/osrf/drcsim.json"}, "html": {"href": "#!/osrf/drcsim"}, "avatar": {"href": "data/bytebucket.org/ravatar/{247b5408-ae91-4e3c-b2f9-a21994658d11}ts=c_plus_plus"}}, "type": "repository", "name": "drcsim", "full_name": "osrf/drcsim", "uuid": "{247b5408-ae91-4e3c-b2f9-a21994658d11}"}, "title": "Provide synchronous control"}, "content": {"raw": "We created a plugin for our use that does basically what we want. It uses protobuff for communication using a simple boost TCP server. Commands are received asynchronously, while state updates are send synchronous. If no packet is received, the plugin re-uses the torque commands from the previous control tick. \n\nWe have tried to make it slightly efficient (using unordered_maps instead of getJoint to resolve jointnames for example), but we haven't profiled and tested it thoroughly yet.\n\nFor debugging, several cheat options are available that can be disabled using defines in the source file\n- Wait for packet, useful for step debugging\n- Receive true world state (robot pose)\n- Setting joint angles (for rewinding the simulation in combination with our controller)\n\nThe plugin itself is in csrc/GazeboStateCommunicator.cc, listening on port 1234.\n\nIt works in tandem with a simple world controller plugin to pause, rewind and resume the simulation. This plugin is in csrc/SimpleWorldPlugin.cc, listening on port 1235.\n\nThe protocol buffers are defined in RobotCommand.proto for torque commands, RobotState.proto for the robot state messages and SimpleWorldControl.proto for gazebo commands. Messages are written to the TCP socket using writeDelimitedTo(included in java protobuffers, simple C++ implementation in ProtoParser.cc) and read using readDelimitedFrom (also included in java protobuffers, simple C++ implementation in ProtoParser.cc)\n\nWe made some launch files in launch/ to start the qualifications.\n\nI've shared the source on bitBucket. The java classes in src are for our own controller and do not work stand alone (but might give an example how to use it).\n\nhttps://bitbucket.org/jespersmith/gazebostatecommunicator/\n\n", "markup": "markdown", "html": "<p>We created a plugin for our use that does basically what we want. It uses protobuff for communication using a simple boost TCP server. Commands are received asynchronously, while state updates are send synchronous. If no packet is received, the plugin re-uses the torque commands from the previous control tick. </p>\n<p>We have tried to make it slightly efficient (using unordered_maps instead of getJoint to resolve jointnames for example), but we haven't profiled and tested it thoroughly yet.</p>\n<p>For debugging, several cheat options are available that can be disabled using defines in the source file\n- Wait for packet, useful for step debugging\n- Receive true world state (robot pose)\n- Setting joint angles (for rewinding the simulation in combination with our controller)</p>\n<p>The plugin itself is in csrc/GazeboStateCommunicator.cc, listening on port 1234.</p>\n<p>It works in tandem with a simple world controller plugin to pause, rewind and resume the simulation. This plugin is in csrc/SimpleWorldPlugin.cc, listening on port 1235.</p>\n<p>The protocol buffers are defined in RobotCommand.proto for torque commands, RobotState.proto for the robot state messages and SimpleWorldControl.proto for gazebo commands. Messages are written to the TCP socket using writeDelimitedTo(included in java protobuffers, simple C++ implementation in ProtoParser.cc) and read using readDelimitedFrom (also included in java protobuffers, simple C++ implementation in ProtoParser.cc)</p>\n<p>We made some launch files in launch/ to start the qualifications.</p>\n<p>I've shared the source on bitBucket. The java classes in src are for our own controller and do not work stand alone (but might give an example how to use it).</p>\n<p><a href=\"https://bitbucket.org/jespersmith/gazebostatecommunicator/\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/jespersmith/gazebostatecommunicator/</a></p>", "type": "rendered"}, "created_on": "2013-04-03T15:42:47.416725+00:00", "user": {"display_name": "Jesper Smith", "uuid": "{61d9fe7d-e554-408c-99fb-faefa9c96114}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B61d9fe7d-e554-408c-99fb-faefa9c96114%7D"}, "html": {"href": "https://bitbucket.org/%7B61d9fe7d-e554-408c-99fb-faefa9c96114%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/56b6560717cfbb0f4a2cc0af6e638650d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJS-4.png"}}, "nickname": "jespersmith", "type": "user", "account_id": "557058:2e842f1c-d9d5-48b1-88ae-5dd9e81a6f77"}, "updated_on": null, "type": "issue_comment", "id": 3608339}